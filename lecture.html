<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>როგორ მუშაობს ინტერნეტი</title>
<meta name="author" content="(ia)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3/css/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@3/css/theme/white.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdn.jsdelivr.net/npm/reveal.js@3/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">როგორ მუშაობს ინტერნეტი</h1><p class="date">Created: 2019-08-15 Thu 12:34</p>
</section>
<aside class="notes">
<p>
ახლა არ მომიწია საერთოდ ამის მოფიქრება, ეს საგანი რომ გავიარე იმდენად აღფრთოვანებული ვიყავი რომ მინდოდა გამოცდისთვის მეცადინეობის პარალელურად გამეკეთებინა ინტერაქციული საიტი შეჯამებით, მაგრამ სხვა გამოცდების წყალობით არ დამცალდა. თან ისეთი თემაა რომ
</p>
<ul>
<li>მანამდეც მინდოდა</li>
<li>საგნის გავლის მერე აღფრთოვანებული ვიყავი</li>
<li>მრავალფეროვანი, საინტერესო</li>

</ul>

</aside>
<section>
<section id="slide-sec-">
<h2 id="orgf3c05b7">რატომ ავირჩიე ეს თემა</h2>
<img src=https://mocomi.com/wp-content/uploads/2016/10/MOC_GIFO_INTERNET1.gif>
<aside class="notes">
<p>
ინტერნეტ პაკეტს ერთგვარი თავგადასავალი აქვს რომლის დროსაც ბევრჯერ იცვლის ფორმას, ტრანსფორმირდება რაღაც სხვად და მერე უკან ეწყობა. ამ პროცესში უამრავი დამოუკიდებელი მოთამაშეა რომელსაც ერთმანეთზე წარმოდგენა არ აქვთ მაგრამ უნაკლოდ ახერხებენ თანამშრომლობას.
ჩემი მიზანია, რომ ლექციის ბოლოს გესმოდეთ უკან ანიმაციაზე რა ხდება და რა როლი აქვს თითოეულ მონაწილეს ამ ყველაფერში.
</p>

</aside>
<aside class="notes">
<p>
ასევე შევეცდები ავხსნა, როგორ ხდება ეს ყველაფერი ასე სწრაფად. წამის მეათედში უამრავი სხვადასხვა კომპიუტერი გვეხმარება რომ საიტზე შევიდეთ, ვიდეო ზარი განვახორციელოთ ან მეილი გავგზავნოთ
</p>

</aside>
<aside class="notes">
<p>
შემეძლო ამეხსნა დისკზე ინფორმაცია როგორ ინახება, ეგეც წამში ძალიან ბევრჯერ ხდება უბრალოდ მაინც უფრო მეტი აღფრთოვანების წყაროა ის რომ თვალის დახამხამებაში ათასობით კილომეტრის იქით ვამყარებთ კავშირს. ამის მისაღწევად მთლიანი დარგი ახალი პრობლემების წინაშე დადგა რომლებიც გენიალურად გადაიჭრა
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org4c0bc65">მთავარი პრობლემა: ყველას თავისი პრიორიტეტი აქვს</h3>
<p>
განსხვავებული:
</p>
<ul>
<li class="fragment appear">მიზნები</li>
<li class="fragment appear">გზები</li>

</ul>
<aside class="notes">
<p>
ინტერნეტს იყენებენ ვიდეოების სანახავად, სტატიების წასაკითხად, ვიდეო ზარების განსახორციელებლად.
კავშირი მყარდება ოპტიკური და <span class="underline">_</span> კაბელით, ან საერთოდ უკაბელოდ,
</p>

</aside>
<aside class="notes">
<p>
ღია და დახურული ქსელები, და ეს ყველაფერი ახერხებს რომ ერთმანეთს შეეწყოს და დაუკავშირდეს მილიწამებში.
როგორ ახერხებენ, რომ სხვადასხვა ქვეყნების ინტერნეტ პროვაიდერებმა უპრობლემოდ გადაამისამართონ ერთმანეთთან პაკეტები
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org7a0f384">მოცემულობა</h3>
<ul>
<li>ინტერნეტ პაკეტები არის პატარა</li>

</ul>
<aside class="notes">
<p>
ერთი საიტი რომ ჩაიტვირთოს რამდენიმე ათეული, ზოგჯერ ასეული პაკეტი უნდა გამოგვიგზავნოს სერვერმა. მიზეზებს მოგვიანებით ვიტყვი
</p>

</aside>
<ul>
<li>10-20 როუტერის გავლაა საჭირო</li>

</ul>
<aside class="notes">
<p>
ჯერ იგზავნება სახლში რომ როუტერი გაქვთ იქ კაბელით ან wifiთ, მერე ეს უკავშირდება სადარბაზოში რომ დგას გამანაწილებელი იქ, მერე სავარაუდოდ შნურია გაყვანილი უბნის, ქალაქის, ქვეყნის - აშ დასაკავშირებლად. და მერე უკან უნდა გაიაროს ეს გზა - იმ ქალაქის, უბნის, სადარბაზოს, სახლის როუტერით მივიდეს მიმღებთან
</p>

</aside>
<ul>
<li>ეს როუტერები ერთი და იგივე არ იქნება</li>

</ul>
</section>
<section id="slide-sec-">
<h3 id="orge6cfd2b">გამოსავალი</h3>
<ul>
<li><p>
პრობლემების ჯგუფებად დაყოფა
</p>
<aside class="notes">
<p>
როდის და როგორ უნდა შემოწმდეს, რომ პაკეტი ნამდვილად მივიდა ადგილზე. ერთ სურათს ჰო ვერ ვგზავნით მთლიანად, უნდა დავშალოთ და მერე ავაწყოთ.
ამ ორს შორის წამში იგზავნება მილიონობით პაკეტი სხვა კომპიუტერებისგან, ხოლო ამ ორს ერთი ფაილი უნდათ. და ყველამ თავის საქმეს უნდა მიხედოს
</p>

</aside></li>
<li>პასუხისმგებლობების დაყოფა დონეებად</li>
<li>ერთ დონეზე ცოტა საკითხი რჩება მოსაგვარებელი</li>
<li>რა გარანტიებსაც ქვედა დონე არ იძლევა, უნდა მოვაგვაროთ</li>

</ul>
</section>
</section>
<section>
<section id="slide-sec-">
<h2 id="orga7b5b7f">ინტერნეტის დონეები</h2>
<div class="outline-text-2" id="text-orga7b5b7f">
</div>
</section>
<section id="slide-sec-">
<h3 id="org99abaa0">ბმული</h3>
<ul>
<li class="fragment appear">ფიზიკური სიგნალის გაგზავნა</li>
<li class="fragment appear">ინტერნეტ პაკეტების საწყისი და ბოლოს მონიშვნა</li>
<li class="fragment appear"><p>
შეცდომების დაფიქსირება და გამოსწორება
</p>
<aside class="notes">
<p>
   მათემატიკის დარგი, ინფორმაციის თეორიაში არსებობს ბევრი სხვადასხვა გზა რომ ნებისმიერი რიცხვითი ინფორმაციის გადაცემისას დაკარგული და დაზიანებული რიცხვები ეფექტურად როგორ აღდგეს. მაგალითად, 1ების და 0ების რაოდენობას თუ მივაწერთ ბოლოში, შევძლებთ რომ აღმოვაჩინოთ, მაგრამ ვერ გამოვასწორებთ.
    <span class="underline">todo polynomial</span> ამისთვის გამოიყენება პოლინომიალის კოეფიციენტები.
   რაც უფრო მეტი დანართი ექნება ამ შეცდომის გამოსასწორებლად, უფრო იზრდება ალბათობა რომ შეცდომა მოხდეს.
   ეს გადაწყვეტილება, რამდენად დიდი რესურსი დაეთმოს შეცდომებს, პირდაპირ არის დამოკიდებულებაში იმაზე, კაბელს ვიყენებთ თუ კაბელის გარეშე.
   ორი მოწყობილობა ერთმანეთთან დავაკავშირეთ, და შემდეგი ლოგიკური ნაბიჯი არის ორი მილიარდი
wifi ტალღებს იყენებს და კედელი, ამინდი - ეს ყველაფერი ხელს უშლის სიგნალის გადაცემას. კაბელში ბევრად ნაკლები ხელის შემშლელი ფაქტორია.
</p>

</aside></li>

</ul>
</section>
<section id="slide-sec-">
<h3 id="orgf74e10e">ქსელი - ყველაზე სწრაფი გზა Aდან Bმდე</h3>
<aside class="notes">
<p>
აქ არის სრული ქაოსი. და ამ მიზანთან ბევრ პრობლემას ვაწყდებით.
ალგორითმებში და დისკრეტულ მათემატიკაში ისწავლება გრაფის თეორია, როგორ ვიპოვოთ ყველაზე მოკლე/სწრაფი გზა ა წერტილიდან ბ წერტილამდე. თავიანთი ორიგინალური ფორმით ვერცერთს გამოვიყენებთ აქ, იმიტომ რომ მთლიანი პლანეტის ქსელი რომ ყველა როუტერში შევინახოთ, ის ალგორითმები <span class="underline">todo</span> დრო მოუნდებიან მხოლოდ ორს შორის ამ გზის დადგენას ადგილს დავკარგავთ. ვიცით მეზობლები, და დანარჩენი მისამართებისთვის გვიწერია შემდეგი ვინ უნდა იყოს.
</p>

</aside>
<img src=https://media.giphy.com/media/112f41tQK1G1ag/giphy.gif>
</section>
<section id="slide-sec-">
<h3 id="orgbbd0e23">ქსელი</h3>
<img src=https://d2vlcm61l7u1fs.cloudfront.net/media%2F4d4%2F4d47e015-ad3a-451c-b18d-0ccbe9ff1b6c%2FphpSan97A.png>
</section>
<section id="slide-sec-">
<h3 id="org5d53156">ქსელი</h3>
<ul>
<li class="fragment appear"><p>
ეს გზა ყოველ წამს იცვლება
</p>
<aside class="notes">
<p>
როგორ დგინდება: ახალი კავშირი შეიქმნა. თავის მეზობლებს აცნობს ერთმანეთს, და ეს მეზობლები ადარებენ არსებულ ინფორმაციას და თუ რამე ახალს გაიგებენ, ამასაც აცნობენ. ამის გავრცელებას დრო ჭირდება და ამასობაში პაკეტები მიმოიცვლება. ეს მოქნილი დიზაინი უზრუნველყოფს იმას, რომ ქსელი დამოუკიდებლად გრძნობს და ძალიან მალე ადაპტირდება ნაკადების ცვლილებაზე. ის პაკეტები ძველი გზით მიდის, მაგრამ
</p>

</aside></li>

</ul>
<ul>
<li class="fragment appear">ახალი კავშირის გამოყენება</li>
<li class="fragment appear">დაკარგულის ალტერნატივის მოძებნა</li>
<li class="fragment appear"><p>
კაბელის გადატვირთვა
</p>
<aside class="notes">
<p>
ამ ორ შემთხვევაში პაკეტი იკარგება. თუ მივიდა რაღაც ადგილამდე და ის შემდეგს ვერ პოულობს, თვალის დაუხამხამებლად, ზედმეტი შეყოვნების და შებრალების გარეშე წაშლის ამ პაკეტს
</p>

</aside></li>

</ul>
</section>
<section id="slide-sec-">
<h3 id="org26ccd1a">ქსელი - პაკეტების დაკარგვა</h3>
<ul>
<li>პაკეტის დაკარგვა მოსალოდნელი მოვლენა</li>
<li>ამისთვის უნდა მოვემზადოთ</li>
<li>todo სხვა მიზეზები ტელეფონიდან</li>

</ul>
</section>
<section id="slide-sec-">
<h3 id="org70e87a9">ტრანსპორტი</h3>
<aside class="notes">
<p>
იმისთვის, რომ ეს პაკეტები უკან აეწყოს, უნდა დაინომროს. ვიღაცას საერთოდ არ აინტერესებს პაკეტების დანომვრა და ზოგი პაკეტის დაკარგვა. უბრალოდ დრო არ არის ამისთვის. ვიდეო ზარის დროს ხმაც და გამოსახულებაც სრულყოფილისგან ძალიან შორს რომ იყოს, ვერ შევამჩნევთ.
</p>

<p>
ყოველთვის არ აქვს აზრი თავიდან გაგზავნას, იმიტომ რომ თუ ვინმე ლაივს უყურებს, ნახევარი წამის წინანდელი კადრი არ აინტერესებს. ვიღაცა თუ კინოს იწერს, კინოს გადმოწერის ბოლომდე არის დრო რომ დაკარგული პაკეტები თავიდან გააგზავნო.
იმის anticipation, რომ (და ეს ორ წამში დამავიწყდა)
</p>

</aside>
<p class="fragment (appear)">
დაკარგული პაკეტები
</p>
<ul>
<li>მიღების დასტურის გაგზავნა</li>

</ul>
<p class="fragment (appear)">
ინფორმაციის აწყობა
</p>
<ul>
<li>გამგზავნი ნომრავს ნაწილებს</li>
<li>მიმღები ადასტურებს კონკრეტული ნომრის მიღებას</li>
<li>რომლის დასტურიც არ მოვა, თავიდან იგზავნება</li>

</ul>
<p class="fragment (appear)">
ამ შრეზე მთავრდება ინტერნეტ პაკეტის "სიცოცხლე"
</p>
</section>
<section id="slide-sec-">
<h4 id="orgddcb00c">სად მთავრდება ინტერნეტ პაკეტის "სიცოცხლე"</h4>
<p class="fragment (appear)">
მოწყობილობის ოპერატიული სისტემა
</p>
<aside class="notes">
<p>
და უკვე აქ ბრაუზერი, სკაიპი, თამაში, outlook: ყველა ეს პროგრამა ახერხებს რომ ერთი მარტივი რაღაც სთხოვოს კომპიუტერს - გამიგზავნე ან ჩემთვის მიიღე რაღაც
</p>

</aside>
</section>
<section id="slide-sec-">
<h4 id="orgdd43956">რა რჩება პროგრამებისთვის?</h4>
<p>
კონკრეტულ აპლიკაციასთან ინტერნეტი მთავრდება და იწყება განაწილებული სისტემები. ამ სფეროს კითხვებში შედის
</p>
<ul>
<li class="fragment appear">როგორ მოვიხმაროთ ეს რესურსები ეფექტურად
<ul>
<li>წავშალოთ თუ შევინახოთ?</li>
<li>რამდენი ხნით?</li>
<li>ცვლილებისას ყველაფერი თავიდან გადმოვწეროთ?</li>

</ul></li>
<li class="fragment appear">როგორ გავუმკლავდეთ ბევრ მომხმარებელს</li>

</ul>
<aside class="notes">
<p>
აუთლუქი ყოველ ჯერზე მთლიან იმეილ ისტორიას არ იწერს
იმის გამო, რომ ყველა სხვა პრობლემა მოვაგვარეთ, დეველოპერებს საშუალება აქვთ საკუთარი დრო და ენერგია მიმართონ იმაზე, რომ ეს გაცვლა-გამოცვლა კიდევ უფრო ადაპტირებული იყოს კონკრეტულ შემთხვევებში მომხმარებლისთვის. მაგალითად, სკაიპის ზარი ეგრევე წაშლის მიღებულ
რაღაც მომენტში გადაწყვეტილი მქონდა რომ ძაან ბევრი ვაუ სტატისტიკა მომეყვანა
</p>

</aside>
</section>
</section>
<section>
<section id="slide-sec-">
<h2 id="org693d505">შეჯამება</h2>
<div class="outline-text-2" id="text-org693d505">
</div>
</section>
<section id="slide-sec-">
<h3 id="org61455e5">რა ავხსენი?</h3>
<aside class="notes">
<p>
ამ ყველაფერს ქვია OSI (<sub>todo</sub>_) დონეები.
და აქ ხედავთ ყველაზე დიდ მცდელობას რომ არსებული ასოების ყველა კომბინაციას რაღაც მნიშვნელობა მიანიჭონ და რისი წყალობითაც მეორე ლექციაზე ეფექტურად განახევრდა დამსწრე თანაკურსელების რიცხვი. მე მაგარი გავერთე იმის წყალობით, რომ ვაიგნორებდი ამ ასოებს და რიცხვებს
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org7a4c8da">რა მნიშვნელობა აქვს კომპიუტერულ ქსელებს სტუდენტისთვის</h3>
<aside class="notes">
<p>
რეალურად, მთლიანი საგანი ეთმობა ამ საკითხს. რატომ უნდა დაუთმოს კომპიუტერული მეცნიერებების სტუდენტმა დრო ქსელების სწავლას?
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org7e889d6">მრავალფეროვანი</h3>
<ul>
<li class="fragment appear">აერთიანებს ბევრ სხვადასხვა დარგს</li>
<li class="fragment appear">ალგორითმების პრაქტიკულობა</li>
<li class="fragment appear">ISOს როლი და მნიშვნელობა</li>

</ul>
<aside class="notes">
<p>
მაგალითად, პროგრამული ენების სპეციფიკაციები, უნიკოდი და ბევრი სხვა რამ რასაც ყოველდღე იყენებენ პროგრამირებაში, ასევე კომიტეტების მიერ დგინდება და აუცილებელია ერკვეოდე ზოგად სისტემაში.
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org8570d5d">საინტერესო და სახალისო საკითხებით სავსე</h3>
<ul>
<li class="fragment appear">შეცვლილია მოცემულობა</li>
<li class="fragment appear">ტოპოლოგიის მრავალფეროვნება</li>
<li class="fragment appear">პრობლემებისთვის სწორი აბსტრაქციების მოფიქრება</li>

</ul>
</section>
<section id="slide-sec-">
<h3 id="org214e9be">ღირებულებები</h3>
<aside class="notes">
<p>
კომპიუტერულ ქსელებში ძალიან კარგად აისახება ის პრაგმატული და მრავლისმომცველი მიდგომა, რაც მთლიან მეცნიერებას ახასიათებს.
</p>

</aside>
<ul class="fragment appear">
<li>არჩევანის თავისუფლება/დამოუკიდებლობა</li>

</ul>
<aside class="notes">
<p>
ნებისმიერი სისტემის დიზაინი უნდა მოხდეს ისე, რომ ზოგადი წესები დაიწეროს. გარდა ამისა
</p>

</aside>
<ul class="fragment appear">
<li>აღწერა და არა გამოგონება (რა/როგორ)</li>

</ul>
<aside class="notes">
<p>
ზედა შრე ყოველთვის აღწერს. ლოგიკა და მექანიზმი დამოუკიდებელი უნდა იყოს ერთმანეთისგან. კაბელის შემქმნელებმა უნდა გამოიგონონ როგორ აასწრაფონ და ერთდროულად ბევრი სიგნალი როგორ გააგზავნონ.
</p>

</aside>
<ul class="fragment appear">
<li>ნებაყოფლობითი წესრიგი/შეთანხმება</li>

</ul>
<aside class="notes">
<p>
უკეთესი ქსელი არის ყველას ინტერესი და კიდევ რამე ასეთი todo
მთელი პლანეტაა დაკავშირებული ერთმანეთთან, უამრავი ღია და დახურული ქსელი
ახერხებს კომუნიკაციას და ეს ყველაფერი ხდება მინიმალური ძალისხმევით, იმიტომ
რომ სისტემის დიზაინი ისეთია რომ ყველაფერს მოერგოს.
</p>

</aside>
<ul class="fragment appear">
<li>დიზაინის და ბალანსის მნიშვნელობა</li>

</ul>
<aside class="notes">
<p>
ყველა პრობლემის მოგვარება ნიშნავს ახალ პრობლემებს. რთულია განსაზღვრა __ და ამიტომ მნიშვნელოვანია რომ ვიცოდეთ მაგალითები და ასევე გვგქონდეს სხვადასხვა იარაღები რომ გავზომოთ cost benefit.
შრეებად დაყოფა შეიმუშავეს 1980 წელს. მაშინ არ გვგქონდა პრობლემები გადატვირთვაზე, მაგრამ თავიდანვე ყველაზე რთული სცენარისთვის მოხდა დიზაინი. "პრაქტიკული" პროგრამირების მოყვარულებისგან ხშირად არის კრიტიკა თითქმის ყველა არაპრორამირების საგანზე. და რეალობა კიდევ ისაა, რომ 'პრაქტიკულ' სამსახურში დროის უმეტესი ნაწილი იხარჯება ისეთი შეცდომების გამოსწორებაზე, როგორიცაა 'ჩვენ არ გვეგონა თუ ამდენი იუზერი გვეყოლებოდა'. და ეს ასევე იმის მაგალითია, რის გამოც აკადემიური განათლება თვითნასწავლობით ვერ
ჩანაცვლდება. ჩემი აზრით ქსელების მუშაობის სპეციფიკა და პროტოკოლები უმეტეს პროგრამისტს და მეცნიერს არასდროს დაჭირდება, მაგრამ მათი სწავლით და აღქმით უნარი და მიდგომა ყალიბდება, რომლითაც უამრავი შეცდომა მოხვედრამდე გამოსწორდება.
</p>

</aside>
</section>
<section id="slide-sec-">
<h3 id="org9ebfd98">მადლობა ყურადღებისთვის</h3>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@3/lib/js/head.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js@3/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js@3/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js@3/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js@3/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js@3/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js@3/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
